"""
Pydantic schemas for workshop notification configuration.

Provides request/response models for the notification config API.
"""
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List, Dict, Any
from datetime import datetime
import json


class ProcessorConfigSchema(BaseModel):
    """Configuration for text formatting and image rendering processors."""

    # Text formatter settings
    text_format: str = Field(default="markdown", description="Output format: markdown, plain, or html")
    max_length: Optional[int] = Field(default=None, description="Maximum text length (null for unlimited)")
    add_header: bool = Field(default=True, description="Add title and workshop name header")
    add_footer: bool = Field(default=False, description="Add 'Generated by MindEcho' footer")

    # Image renderer settings
    render_image: bool = Field(default=False, description="Enable image rendering via RPC")
    image_style: str = Field(default="minimal_card", description="Image rendering style")
    image_size: str = Field(default="1080x1920", description="Image dimensions (WxH)")

    @field_validator("text_format")
    @classmethod
    def validate_text_format(cls, v: str) -> str:
        allowed = ["markdown", "plain", "html"]
        if v not in allowed:
            raise ValueError(f"text_format must be one of {allowed}")
        return v

    @field_validator("max_length")
    @classmethod
    def validate_max_length(cls, v: Optional[int]) -> Optional[int]:
        if v is not None and v <= 0:
            raise ValueError("max_length must be positive or null")
        return v


class LocalStorageNotifierConfigSchema(BaseModel):
    """Configuration for local storage notifier."""
    output_dir: str = Field(default="./notifications", description="Output directory path")
    organize_by_date: bool = Field(default=True, description="Create YYYY-MM-DD subdirectories")
    save_images: bool = Field(default=True, description="Save rendered images")
    save_metadata: bool = Field(default=True, description="Save metadata JSON")


class EmailNotifierConfigSchema(BaseModel):
    """Configuration for email notifier."""
    subject_template: str = Field(default="MindEcho: {title}", description="Email subject template")
    # SMTP settings come from environment variables, not stored per-workshop


class NotifierConfigSchema(BaseModel):
    """Union of all notifier configurations."""
    local_storage: Optional[LocalStorageNotifierConfigSchema] = None
    email: Optional[EmailNotifierConfigSchema] = None


class WorkshopNotificationConfigCreate(BaseModel):
    """Request schema for creating notification config."""
    workshop_id: str = Field(..., description="Workshop ID to configure")
    enabled: bool = Field(default=True, description="Enable notifications for this workshop")
    processors: List[str] = Field(default=["text_formatter"], description="List of processor names")
    notifier_type: str = Field(default="local_storage", description="Notifier type: local_storage, email")
    processor_config: ProcessorConfigSchema = Field(default_factory=ProcessorConfigSchema)
    notifier_config: Dict[str, Any] = Field(default_factory=dict, description="Notifier-specific config")

    @field_validator("processors")
    @classmethod
    def validate_processors(cls, v: List[str]) -> List[str]:
        allowed = ["text_formatter", "text_formatter_plain", "image_renderer"]
        for proc in v:
            if proc not in allowed:
                raise ValueError(f"Invalid processor: {proc}. Allowed: {allowed}")
        return v

    @field_validator("notifier_type")
    @classmethod
    def validate_notifier_type(cls, v: str) -> str:
        allowed = ["local_storage", "email"]
        if v not in allowed:
            raise ValueError(f"notifier_type must be one of {allowed}")
        return v


class WorkshopNotificationConfigUpdate(BaseModel):
    """Request schema for updating notification config."""
    enabled: Optional[bool] = None
    processors: Optional[List[str]] = None
    notifier_type: Optional[str] = None
    processor_config: Optional[ProcessorConfigSchema] = None
    notifier_config: Optional[Dict[str, Any]] = None

    @field_validator("processors")
    @classmethod
    def validate_processors(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        if v is None:
            return v
        allowed = ["text_formatter", "text_formatter_plain", "image_renderer"]
        for proc in v:
            if proc not in allowed:
                raise ValueError(f"Invalid processor: {proc}. Allowed: {allowed}")
        return v

    @field_validator("notifier_type")
    @classmethod
    def validate_notifier_type(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        allowed = ["local_storage", "email"]
        if v not in allowed:
            raise ValueError(f"notifier_type must be one of {allowed}")
        return v


class WorkshopNotificationConfigResponse(BaseModel):
    """Response schema for notification config."""
    id: int
    workshop_id: str
    enabled: bool
    processors: List[str]
    notifier_type: str
    processor_config: ProcessorConfigSchema
    notifier_config: Dict[str, Any]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

    @classmethod
    def from_orm_model(cls, db_model: Any) -> "WorkshopNotificationConfigResponse":
        """
        Convert ORM model to response schema.

        Handles JSON deserialization for processors, processor_config, and notifier_config.
        """
        return cls(
            id=db_model.id,
            workshop_id=db_model.workshop_id,
            enabled=bool(db_model.enabled),
            processors=json.loads(db_model.processors),
            notifier_type=db_model.notifier_type,
            processor_config=ProcessorConfigSchema(**json.loads(db_model.processor_config)),
            notifier_config=json.loads(db_model.notifier_config),
            created_at=db_model.created_at,
            updated_at=db_model.updated_at,
        )
