import asyncio
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

from app.db.models import Task, FavoriteItem, Result, TaskStatus
from app.schemas.unified import TaskCreate
from app.crud import crud_favorites
from app.core.websocket_manager import manager
from client_sdk.rpc_client import EAIRPCClient

async def start_workshop_task(db: AsyncSession, *, workshop_id: str, collection_id: int) -> Task:
    """
    Creates a new task record in the database for a workshop execution.
    """
    task_in = TaskCreate(
        workshop_id=workshop_id, 
        status=TaskStatus.PENDING,
        favorite_item_id=collection_id  # We'll add this to the schema
    )
    db_task = Task(**task_in.dict())
    db.add(db_task)
    await db.commit()
    await db.refresh(db_task)
    return db_task

async def run_workshop_task(
    db: AsyncSession, *, task_id: int, result_to_update_id: Optional[int] = None
):
    """
    Runs the actual AI workshop task in the background.
    Can either create a new result or update an existing one.
    """
    task = await db.get(Task, task_id)
    if not task:
        print(f"Task with id {task_id} not found.")
        return

    try:
        # 1. Set status to in_progress and notify client
        task.status = TaskStatus.IN_PROGRESS
        db.add(task)
        await db.commit()
        await manager.send_json(str(task_id), {"status": "in_progress", "message": "Starting AI task..."})
        
        # Simulate some work
        await asyncio.sleep(2)
        await manager.send_json(str(task_id), {"status": "in_progress", "message": "Fetching content..."})
        
        # In a real scenario, you'd fetch the content of the FavoriteItem here.
        # For now, we'll use a placeholder.
        
        # 2. Call the AI service (client_sdk)
        await manager.send_json(str(task_id), {"status": "in_progress", "message": "Processing with AI..."})
        
        # Placeholder for client_sdk call
        client = EAIRPCClient(base_url="http://127.0.0.1:8008", api_key="testkey")
        ai_result_text = ""
        try:
            await client.start()
            # This is a placeholder for the actual RPC call which might be a streaming one
            # For example: client.get_summary(content="...")
            # We simulate a streaming response
            placeholder_text = "This is a summary generated by the AI model. It analyzes the content and provides key insights."
            for char in placeholder_text:
                await asyncio.sleep(0.05)
                await manager.send_json(str(task_id), {"status": "in_progress", "type": "token", "data": char})
            ai_result_text = placeholder_text

        finally:
            await client.stop()

        # 3. Save or Update the result
        if result_to_update_id:
            result_to_update = await db.get(Result, result_to_update_id)
            if result_to_update:
                result_to_update.content = ai_result_text
                result_to_update.task_id = task.id
                db.add(result_to_update)
            else:
                # Fallback to creating a new one if the old one is gone
                new_result = Result(
                    workshop_id=task.workshop_id,
                    content=ai_result_text,
                    task_id=task.id,
                    favorite_item_id=task.favorite_item_id # We'll need to add this to the Task model
                )
                db.add(new_result)
        else:
             new_result = Result(
                workshop_id=task.workshop_id,
                content=ai_result_text,
                task_id=task.id,
                favorite_item_id=task.favorite_item_id # We'll need to add this to the Task model
            )
             db.add(new_result)
        
        # 4. Set status to success and notify client
        task.status = TaskStatus.SUCCESS
        db.add(task)
        await db.commit()
        await manager.send_json(str(task_id), {"status": "success", "message": "Task completed.", "result": ai_result_text})

    except Exception as e:
        task.status = TaskStatus.FAILURE
        db.add(task)
        await db.commit()
        await manager.send_json(str(task_id), {"status": "failure", "message": str(e)})
    finally:
        # Disconnect the websocket after the task is done
        manager.disconnect(str(task_id))
